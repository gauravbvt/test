<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <meta attribute="@design.default-queries"/>
    <query name="allIssues">
        <query-param name="project" type="java.lang.Long"/>
        select i as issue
from Issue i
where i.project.id = :project and exists (from IssueComment ic where ic.issue = i)
order by i.sequence
    </query>
    <query name="resourceValues">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="keyword" type="java.lang.String"/>
        select distinct k.val from ResourceAttribute k where k.resource.project.id = :project and k.name = :keyword order by  k.val
    </query>
    <query name="otherFlowIssues">
        <query-param name="flow" type="java.lang.Long"/>
        <query-param name="project" type="java.lang.Long"/>
        from IssueComment ic join fetch ic.issue
where ic.issue.project.id = :project and not ic.id in (select icf.issueComment.id from IssueCommentFlows icf where icf.flow.id = :flow)
order by ic.issue.sequence
    </query>
    <query name="maxIssueSequence">
        <query-param name="project" type="java.lang.Long"/>
        select max(i.sequence) as last
from Issue i
where i.project.id = :project
    </query>
    <query name="issueApproaches">
        <query-param name="issue" type="java.lang.Long"/>
        select ia.approach as approach
from IssueApproach ia join fetch ia.approach.interview
where ia.id.issueId = :issue
    </query>
    <query name="issuesByCategory">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="category" type="java.lang.Long"/>
        select distinct i.id as key, i as issue,
(select count(*) from IssueComment ic where ic.issue.id = i.id ) as comments,
(select count(*) from IssueApproach ia where ia.issue.id = i.id ) as approaches,
(select count(distinct icf.flow.id) from IssueCommentFlows icf where icf.issueComment.issue.id = i.id ) as flows,
(select count(distinct icf.flow.documents) from IssueCommentFlows icf where icf.issueComment.issue.id = i.id and not icf.flow.documents is null) as documents
from Issue i
where i.project.id = :project
and ( :category = -1L or exists (from IssueIssueCategory iic where iic.id.issueId = i.id and iic.id.issueCategoryId = :category )  )
and exists (from IssueComment ic where ic.issue.id = i.id)
order by i.sequence
    </query>
    <query name="approachIssueCount">
        <query-param name="project" type="java.lang.Long"/>
        select a as approach, (select count(ia.issue) from IssueApproach ia where ia.approach=a.id) as issues
from Approach a join fetch a.interview
where a.interview.resource.project.id = :project
order by a.name
    </query>
    <query name="otherCategories">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="issue" type="java.lang.Long"/>
        from IssueCategory ic
where ic.project.id = :project
and not ic.id in (select iic.issueCategory.id from IssueIssueCategory iic where iic.issue.id = :issue)
order by ic.name
    </query>
    <query name="approachIssues">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="approach" type="java.lang.Long"/>
        select ia.issue as issue
from IssueApproach ia
where ia.issue.project.id = :project
and ia.approach.id = :approach
order by ia.issue.sequence
    </query>
    <query name="upcomingInterviews">
        <query-param name="project" type="java.lang.Long"/>
        select i as interview, i.scheduled as scheduled, i.resource.name as name from Interview i
where i.done = 0
and i.resource.project.id = :project
order by i.scheduled
    </query>
    <query name="resourceKeywords">
        <query-param name="project" type="java.lang.Long"/>
        select distinct k.name from ResourceAttribute k where k.resource.project.id = :project order by k.name
    </query>
    <query name="otherIssueApproaches">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="issue" type="java.lang.Long"/>
        from Approach a
where a.interview.resource.project.id = :project
and not a.id in (select ia.approach.id from IssueApproach ia where ia.issue.id = :issue)
order by a.name
    </query>
    <query name="issueCategoryCounts">
        <query-param name="project" type="java.lang.Long"/>
        select iic.issueCategory as category, iic.issueCategory.name as name, count(iic.issue.id) as issues
from IssueIssueCategory iic
where iic.issue.project.id = :project
group by iic.issueCategory
order by iic.issueCategory.name
    </query>
    <query name="documentIssueCount">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="category" type="java.lang.Integer"/>
        select f.documents.id as id, f.documents.document as doc, count(distinct icf.issueComment.issue.id) as issues
from Flow f
join f.issueCommentFlowses icf
where f.interview.resource.project.id = :project
and f.documents.documentCategory.id = :category
group by f.documents
order by f.documents.document
    </query>
    <query name="issueFlows">
        <query-param name="issue" type="java.lang.Long"/>
        select distinct icf.flow as flow
from IssueCommentFlows icf join fetch icf.flow.interview left join fetch icf.flow.documents left join fetch icf.flow.documents.documentCategory
where icf.issueComment.issue.id = :issue
order by icf.flow.fromActor,icf.flow.toActor,icf.flow.name
    </query>
    <query name="availableApproaches">
        <query-param name="issue" type="java.lang.Long"/>
        <query-param name="project" type="java.lang.Long"/>
        from Approach a
where a.interview.resource.project.id =  :project and a.id not in (select ia.id.approachId from IssueApproach ia where ia.id.issueId = :issue)
order by a.name
    </query>
    <query name="otherIssueFlows">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="issueComment" type="java.lang.Long"/>
        from Flow f
where f.interview.resource.project.id = :project and not f.id in (select icf.flow.id from IssueCommentFlows icf where icf.issueComment.id = :issueComment)
order by f.fromActor,f.toActor,f.name
    </query>
    <query name="documentCategoryIssueCounts">
        <query-param name="project" type="java.lang.Long"/>
        select distinct f.documents.documentCategory as category,  f.documents.documentCategory.name as phase,count(icf.issueComment.issue.id) as issues
from Flow f
join f.issueCommentFlowses icf
where f.interview.resource.project.id = :project
group by f.documents.documentCategory
order by f.documents.documentCategory.sequence
    </query>
    <query name="interviewIssues">
        <query-param name="resource" type="java.lang.Long"/>
        select ic.interview.resource.id, ic.interview.resource.name, ic.issue.sequence as  issue, ic.issue.description  as description
from IssueComment ic
where ic.interview.resource.id = :resource
order by ic.interview.resource.name
    </query>
    <query name="addressedIssues">
        <query-param name="project" type="java.lang.Long"/>
        from Issue i
where i.project.id = :project
and exists (select ia.id.approachId from IssueApproach ia where ia.id.issueId = i.id )
    </query>
    <query name="otherApproachIssues">
        <query-param name="approach" type="java.lang.Long"/>
        <query-param name="project" type="java.lang.Long"/>
        from Issue i
where i.project.id = :project and not i.id in (select ia.issue.id from IssueApproach ia where ia.approach.id = :approach)
order by i.sequence
    </query>
    <query name="recentInterviews">
        <query-param name="project" type="java.lang.Long"/>
        select  i.id as id, i.resource.name as resource, i as interview,
count(distinct a.id) as approaches,
count(distinct f.id) as flows,
count(distinct ic.id) as issues,
count(distinct dec.id) as decisions
from Interview i  left join i.flows f left join i.approachs a left join i.issueComments ic left join i.decisions dec
where i.resource.project.id = :project
and i.done = 1
and i.scheduled in (select max(s.scheduled) from Interview s where s.resource = i.resource and s.done = 1)
group by i.resource
order by i.resource.name
    </query>
    <query name="allDocsWithIssues">
        <query-param name="project" type="java.lang.Long"/>
        select distinct f.documents
from Flow f
join f.issueCommentFlowses icf
where f.interview.resource.project.id = :project
order by f.documents.document
    </query>
    <query name="documentIssues">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="document" type="java.lang.Integer"/>
        <query-param name="phase" type="java.lang.Integer"/>
        select distinct icf.issueComment.issue.id as id,
icf.issueComment.issue as issue,
(select count(*) from IssueApproach ia where ia.issue.id = icf.issueComment.issue.id ) as approaches
from Flow f
join f.issueCommentFlowses icf
where f.interview.resource.project.id = :project
and ( :document = -1 or f.documents.id = :document )
and ( :phase = -1 or  f.documents.documentCategory.id = :phase)
order by icf.issueComment.issue.sequence
    </query>
    <query name="flowsByProject">
        <query-param name="project" type="java.lang.Long"/>
        from Flow f join fetch f.interview
where f.interview.resource.project.id = :project
order by f.fromActor, f.toActor, f.name
    </query>
    <query name="otherDecisionFlows">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="decision" type="java.lang.Integer"/>
        from Flow f
where f.interview.resource.project.id = :project and not f.id in (select df.flow.id from DecisionFlow df where df.decision.id = :decision)
order by f.fromActor,f.toActor,f.name
    </query>
    <query name="otherFlowDecisions">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="flow" type="java.lang.Long"/>
        from Decision d
where d.interview.resource.project.id = :project and not d.id in (select df.decision.id from DecisionFlow df where df.flow.id = :flow)
order by d.name
    </query>
    <query name="decisionCounts">
        <query-param name="project" type="java.lang.Long"/>
        select d as decision,
(select count(*) from DecisionFlow df where df.id.decision=d.id) as flows,
(select count(distinct icf.issueComment.issue) from IssueCommentFlows icf where icf.id.flows in (select df.id.flow from DecisionFlow df where df.id.decision = d.id)) as issues,
(select count(distinct ia.id.approachId) from IssueApproach ia where ia.id.issueId in
(select icf.issueComment.issue.id from IssueCommentFlows icf where icf.id.flows in (select df.id.flow from DecisionFlow df where df.id.decision = d.id))) as approaches
from Decision d join fetch d.interview
where d.interview.resource.project.id = :project
order by d.name
    </query>
    <query name="metadataKeys">
        <query-param name="project" type="java.lang.Long"/>
        select distinct ra.name as dimension from ResourceAttribute ra
where ra.resource.project.id = :project
order by ra.name
    </query>
    <query name="metadataCount">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="name" type="java.lang.String"/>
        select ra.val as value, count(distinct ic.issue) as issues
from ResourceAttribute ra join ra.resource.interviews int join int.issueComments ic
where ra.resource.project.id = :project and ra.name = :name
group by ra.val
order by ra.val
    </query>
    <query name="test">
        from Resource r
where exists (from ResourceAttribute ra where ra.resource.id = r.id and ra.name=&apos;VPU&apos; and ra.val=&apos;South Asia&apos;)
    </query>
    <query name="metadataIssues">
        <query-param name="project" type="java.lang.Long"/>
        <query-param name="name" type="java.lang.String"/>
        <query-param name="value" type="java.lang.String"/>
        select ic.issue as issue, count(ic) as comments
from ResourceAttribute ra join ra.resource.interviews int join int.issueComments ic
where ra.resource.project.id = :project and ra.name = :name and ra.val = :value
group by ic.issue
order by ic.issue.sequence
    </query>
</hibernate-mapping>