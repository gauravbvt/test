<html><body>
<h1>Commands</h1>

<p>All user-initiated changes to the data model <b>must</b> be done via the execution of commands.</p>

<p>Commands are executed either:</p>
<ul>
    <li>Immediately</li>
    <li>Later in a session when undoing or redoing a prior command</li>
    <li>After a server restart when replaying journaled commands</li>
</ul>

<p>This means that a command must be totally self-contained and be able
    to execute after being serialized and deserialized, even after a server restart.</p>

<p>One major difficulty is that model object (MO) IDs are unique only within the lifetime of a running instance of Channels
    and are re-used across startups. Care must thus be taken to correctly interpret IDs across restarts. Another
    difficulty has to do with undoing deletions. When undoing the deletion of a model object, the un-deleted model
    object has a different ID than the model object that was deleted. Prior commands still refer to the old ID that
    must then be mapped to the new IDs.
</p>

<p> Commands must not have any meaningful side-effect other than those that its undo command will
    reverse when executed.</p>

<h2>Constructor</h2>

<ul>
<li>Put all initial state in arguments (never put MOs as argument values, only their IDs)</li>
<li>Add to conflicting set the IDs of MOs that, if in the locking set of a later executed
    command by any user, will prevent an undo or redo of this command.
    IDs in conflict set are automatically put in locking set.</li>
<li>Add to locking set the IDs of all other MOs for which locks are required for the execution of the command</li>
</ul>

<h2>Execute</h2>
<ul>
<li>Always use commander to resolve IDs or to find MOs given
    their IDs (ID may have been retired or may be mapped to new IDs since the command was initially constructed). </li>
 <li>If the command may be executed to undo the delete of an MO, re-acquire any prior state from arguments. </li>
<li>Preserve in arguments an MO's ID and state if deleting it.</li>
<li>When un-deleting a MO (a prior state is in the arguments), apply the state preserved.</li>
<li>If MO is re-created (there is a corresponding old ID in the arguments),
    tell commander to map the old ID from argument to ID of new instance.</li>
<li> When deleting an MO, remove its ID from the locking set.</li>
</ul>

<h2>Making undo commands</h2>
<ul>
<li>Create an undoing command, or a multi-command (with undoing commands) if the command causes many undoable changes.</li>
<li>Set the arguments of an undoing command from those of the command it undoes.</li>
<li>Make sure to transfer in the arguments the old IDs of MOs to be un-deleted or de-created.</li>
<li>Make sure to pass in the arguments the states of MOs to be un-deleted.</li>
</ul>

<p> <b>Warning:</b> If any of these guidelines is not applied or is incorrectly applied, the consequence will be delayed 
    failure that can be rather hard to track back to its original cause.</p>

</body></html>